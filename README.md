# README - DapperRepository

Repositório genérico para acesso a dados usando **Dapper**, com foco em simplicidade, performance e baixo acoplamento.  
Segue o padrão de Repositório e Unidade de Trabalho descritos por Martin Fowler, sem impor novas linguagens, controle de estado ou proxies dinâmicos.

Este componente foi desenhado para uso direto com POCOs decorados com metadados que orientam a consulta, persistência e relacionamento entre entidades.

---

## 📌 Instalação

```bash
dotnet add package Rochas.DapperRepository
```

---

## 📌 Nome da Interface

```text
IGenericRepository<T>
```

## 📌 Exemplo de uso típico — Instância manual:

```csharp
var connString = "Data Source=sample.db;Cache=Shared";

using (var repo = new GenericRepository<SampleEntity>(DatabaseEngine.SQLite, connString))
{
    var result = repo.List();
}
```

## 📌 Exemplo de Registro no DI

```csharp
services.AddScoped<IGenericRepository<SampleEntity>>(provider =>
    new GenericRepository<SampleEntity>(
        DatabaseEngine.SQLite,
        configuration.GetConnectionString("Default")));
```

Implementação em serviço de domínio:

```csharp
private readonly IGenericRepository<SampleEntity> _repo;

    public SampleService(IGenericRepository<SampleEntity> repo)
    {
        _repo = repo;
    }
```

---

## 📌 Exemplo de Entidade (Metadados Reais)

```csharp
[Cacheable]
[Table("sample_entities")]
public class SampleEntity
{
    [Key]
    [AutoGenerated]
    public int Id { get; set; }

    [Column("creation_date")] 
    [RangeFilter(LinkedRangeProperty = "CreationDateEnd")] 
    public DateTime CreationDate { get; set; } 
    
    [NotMapped] 
    public DateTime CreationDateEnd { get; set; }

    [Filterable]
    [Column("name")]
    public string Name { get; set; }

    [Column("age")]
    public int Age { get; set; }

    [Column("active")]
    public bool Active { get; set; }

    [RelatedEntity(Cardinality = RelationCardinality.OneToMany, 
                   ForeignKeyAttribute = "ParentId")]
    public IList<ChildEntity> Childs { get; set; }
}

[Table("child_entities")]
public class ChildEntity
{
    [Key]
    public int Id { get; set; }

    public int ParentId { get; set; }

    public string Description { get; set; }
}
```

## 🔧 Métodos CRUD disponíveis no repositório

### ➕ Add (inclusão de entidade no repositório)

```csharp
var entity = new SampleEntity
{
    Name = "Renato Rocha",
    Email = "rrocha@example.com"
};

repo.Add(entity);
```

### ➕ AddRange (inclusão de múltiplas entidades no repositório)

```csharp
var list = new List<SampleEntity>() { 
                new SampleEntity() {
                    Name = "Renato Rocha",
                    Resume = "Software Architect"
                },
                new SampleEntity() {
                    Name = "Roberto Dias",
                    Resume = "Infra DevOps"
                },
            };

repo.AddRange(list);
```

### ✏️ Update (atualização de entidade do repositório)
```csharp
var filter = new SampleEntity { DocNumber = 12345 };
var entityToUpdate = await repo.Get(filter);
entityToUpdate.Age = 40;

int affected = await repo.Update(entityToUpdate, filter);
```

### ❌ Remove (remoção de entidade do repositório)
```csharp
var filterToRemove = new SampleEntity { DocNumber = 12345 };

int removed = await repo.Remove(filterToRemove);
```

---

## 🔍 Query (consultas por filtro tipado)
```csharp
var all = await repo.Query(new SampleEntity()); //Listar todos

var filter = new SampleEntity { Name = "Roberto", Email = "gmail.com" };
var results = await repository.Query(filter, recordsLimit:10);
```

Utilize o parâmetro booleano **filterConjunction** para definir o comportamento dos 
atributos na consulta, conjunção lógica E (ligado), disjunção lógica OU (desligado).

Quando a conjunção é utilizada o critério aplicado é de igualdade, do contrário semelhança.

---

## 🔍 Query (consultas por intervalo `[RangeFilter]`)
```csharp
var filter = new SampleEntity
{
    CreatedAtStart = new DateTime(2024, 01, 01),
    CreatedAtEnd   = new DateTime(2024, 12, 31)
};

var results = await repository.Query(filter);
```

Somente atributos marcados com `[RangeFilter]` e referência ao atributo auxiliar.

---

## 🔎 Search (buscas usando `[Filterable]`)
```csharp
var results = await repository.Search("Rua Bruchelas");
```

Somente atributos marcados com `[Filterable]` entram automaticamente na busca.

---

## ⚡ Cache Interno usando `[Cacheable]`

Ao marcar a entidade:

```csharp
[Cacheable]
```

O repositório ativa o gerenciamento automático de cache.

É possível ligar/desligar o cache no construtor:

```csharp
var repos = new GenericRepository<SampleEntity>(DatabaseEngine.SQLite, connString, useCache: true);
```

---

## 🔗 Leitura automática da composição usando `[RelatedEntity]`
```csharp
repos.Query(filterEntity, loadComposition: true)
);
```

Configuração de relacionamentos ( 1-1, 1->N, N<-1, N<->N ):
```csharp
[RelatedEntity(Cardinality = RelationCardinality.OneToOne, 
               ForeignKeyAttribute = "ParentId")] 
public <ChildEntity> Child { get; set; }

[RelatedEntity(Cardinality = RelationCardinality.OneToMany, 
               ForeignKeyAttribute = "ParentId")] 
public IList<ChildEntity> Childs { get; set; }
```

